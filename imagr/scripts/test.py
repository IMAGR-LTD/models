import re
import datetime

# Compile the regex pattern
pattern = re.compile(
    r"^(?P<timestamp>\d+)_(?P<camera_id>\d+)_(?P<event_id>[a-z\d-]+)\.bayer"
)

filename = "1690520125690_2_91b864e4-cd3f-f5c8-00fe-9167207a6b8b.bayer"

matched = pattern.match(filename)
print(matched)
timestamp = matched.group('timestamp')
print(matched.group('camera_id'))
print(matched.group('event_id'))

datetime = datetime.datetime.fromtimestamp(
            int(timestamp) / 1000, tz=datetime.timezone.utc
        )

print(datetime)

# class OnboardingImage(Image, abc.ABC):
#     """Container for images generated by devices in the onboarding flow.

#     Compared to :class:`Image`, additional metadata is available that is parsed from
#     the file's path and name.

#     Attributes:
#          BARCODE_RE: Regex used to parse the image's barcode from its path.
#          IMAGE_RE: Regex used to parse the image's filename.
#     """

#     BARCODE_RE = re.compile(r"[a-z0-9-]+(?:-[a-z0-9-]+)?")
#     IMAGE_RE: re.Pattern

#     def __init__(
#         self,
#         path: str,
#         data=None,
#         size_in_bytes=None,
#         is_augmented: bool = False,
#     ):
#         assert path is not None
#         super().__init__(path, data, size_in_bytes, is_augmented)
#         self._barcode = self._parse_barcode()

#     def __str__(self) -> str:
#         return (
#             f"OnboardingImage(barcode={self.barcode}, augmented={self.is_augmented}, "
#             f"path={self.path})"
#         )

#     @property
#     def filename(self) -> str:
#         return Path(self.path).name

#     def filename_with_suffix(self, suffix: str) -> str:
#         return Path(self.path).with_suffix(f'.{suffix}').name

#     @property
#     def barcode(self) -> str:
#         return self._barcode

#     @property
#     @abc.abstractmethod
#     def timestamp(self) -> Union[float, datetime.datetime, None]:
#         """Get the timestamp that reflects when this image was taken.

#         Todo:
#             This should probably always return a datetime.
#         """
#         raise NotImplementedError

#     @property
#     @abc.abstractmethod
#     def camera(self) -> str:
#         """Get the identifier of the camera that took this image.

#         Can be either a name or an index, depending on the device type.
#         """
#         raise NotImplementedError

#     @property
#     @abc.abstractmethod
#     def camera_hostname(self) -> str:
#         raise NotImplementedError

#     def generate_augmented_version(
#         self, data, output_dir: str, suffix: str
#     ) -> "OnboardingImage":
#         """Generate an augmented image based on this image.

#         This method calls ``from_ndarray`` internally. It is up to the user to actually
#         augment the image. This method just creates a new :class:`CartImage` instance
#         that saves the image under a path that is derived from the original image's
#         path.

#         Args:
#             data: The data representing the augmented image.
#             output_dir: Parent directory that is used as the start of the path of the
#                 new instance.
#             suffix: Suffix added to the filename, right before the extension.

#         Returns:
#             A new onboarding image that has its path based on this instance's path.
#         """
#         path_ = Path(self.path)
#         return self.from_ndarray(
#             data,
#             FileSystems.join(output_dir, self.barcode, "augmentations", f"{path_.stem}_{suffix}.jpeg"),
#         )

#     def _parse_barcode(self) -> str:
#         candidates = [
#             part for part in Path(self.path).parts if self.BARCODE_RE.fullmatch(part)
#         ]

#         candidates_length = len(candidates)

#         if candidates_length == 1:
#             return candidates[0]

#         if candidates_length > 1:
#             candidate = candidates[-1]
#             logging.debug(
#                 f"Multiple barcodes ({candidates}) detected in: '{self.path}'. "
#                 f"Picking the latest: {candidate}"
#             )
#             return candidate

#         raise ValueError(
#             f"Could not detect barcode in: '{self.path}'."
#         )

#     @classmethod
#     def _match_filename_regex(cls, path) -> re.Match:
#         """Match the stemmed filename against the filename regular expression.
#         Requires a full match.
#         Todo:
#             Use this also for the Yuzu subclass. Requires renaming of test files.
#         Raises:
#             RuntimeError: if the stemmed filename does not fully match the regex.
#         Returns:
#             The match object.
#         """
#         if match := cls.IMAGE_RE.match(Path(path).stem):
#             return match
#         else:
#             raise RuntimeError(
#                 f"Invalid filename: '{path}', pattern: {cls.IMAGE_RE}."
#             )

#     @abc.abstractmethod
#     def crop(self, bbox: Tuple[int, int, int, int],) -> 'OnboardingImage':
#         raise NotImplementedError

#     @abc.abstractmethod
#     def with_base_dir_and_suffix(self, base_dir: str, suffix: str) -> 'OnboardingImage':
#         raise NotImplementedError